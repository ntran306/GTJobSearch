{% load static %}
{% load custom_filters %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}BuzzedIn{% endblock %}</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/style.css' %}">
    <link rel="icon" type="image/png" sizes="32x32" href="{% static 'img/favicon-32x32.png' %}">
    <link rel="icon" type="image/png" sizes="16x16" href="{% static 'img/favicon-16x16.png' %}">
</head>
<body>
    <header>
        <nav class="navbar">
            <div class="navbar-inner">
                <div class="logo">
                    <a href="{% url 'home:index' %}">
                        <img src="{% static 'img/Buzz.png' %}" alt="BuzzedIn Logo" class="logo-icon">
                        <img src="{% static 'img/BuzzedIn.png' %}" alt="BuzzedIn" class="logo-text">
                    </a>
                </div>

                <ul class="nav-links">
                    {% if user.is_authenticated %}
                        <li>
                            <a href="{% url 'home:index' %}"
                            class="{% if request.resolver_match.view_name == 'home:index' %}active{% endif %}">
                            Home
                            </a>
                        </li>

                        <li>
                            <a href="{% url 'accounts:profile' %}"
                            class="{% if request.resolver_match.view_name == 'accounts:profile' %}active{% endif %}">
                            Profile
                            </a>
                        </li>

                        <li>
                            <a href="{% url 'accounts:connect' %}"
                            class="{% if request.resolver_match.view_name == 'accounts:connect' %}active{% endif %}">
                            Connect
                            </a>
                        </li>

                        {% if user|has_recruiterprofile %}
                            <li>
                                <a href="{% url 'candidates:search_candidates' %}"
                                class="{% if request.resolver_match.view_name == 'candidates:search_candidates' %}active{% endif %}">
                                Find Candidates
                                </a>
                            </li>
                            <li>
                                <a href="{% url 'jobs:my_jobs' %}"
                                class="{% if request.resolver_match.view_name == 'jobs:my_jobs' %}active{% endif %}">
                                My Job Postings
                                </a>
                            </li>
                        {% elif user|has_jobseekerprofile %}
                            <li>
                                <a href="{% url 'jobs:index' %}"
                                class="{% if request.resolver_match.view_name == 'jobs:index' %}active{% endif %}">
                                Find Jobs
                                </a>
                            </li>
                            <li>
                                <a href="{% url 'applications:view_applications' %}"
                                class="{% if request.resolver_match.view_name == 'applications:view_applications' %}active{% endif %}">
                                My Applications
                                </a>
                            </li>
                        {% endif %}

                        <li>
                            <a href="{% url 'accounts:logout' %}" class="btn btn-primary">Logout</a>
                        </li>
                    {% else %}
                        <li>
                            <a href="{% url 'accounts:signup_choice' %}"
                            class="{% if request.resolver_match.view_name == 'accounts:signup_choice' %}active{% endif %}">
                            Create Profile
                            </a>
                        </li>
                        <li>
                            <a href="{% url 'accounts:login' %}" class="btn btn-primary">Login</a>
                        </li>
                    {% endif %}
                </ul>

                <button class="mobile-menu-btn">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </nav>
    </header>

    {% if messages %}
    <div class="messages">
        {% for message in messages %}
        <div class="message {{ message.tags }}">
            {{ message }}
        </div>
        {% endfor %}
    </div>
    {% endif %}

    <main>
        <section class="section">
            <div class="container">
                {% block content %}{% endblock %}
            </div>
        </section>
    </main>

    {% if user.is_authenticated %}
    <!-- Floating Chat HTML -->
    <button id="bzChatFab" class="bz-chat-fab" aria-label="Open messages">
        <i class="fa-solid fa-message"></i>
        <!-- Unread notification dot -->
        <span id="bzChatUnreadDot" class="bz-chat-unread-dot"></span>
    </button>

    <div id="bzChatPanel" class="bz-chat-panel" role="dialog" aria-modal="false">
        <div class="bz-chat-header">
            <span>Messages</span>
            <button id="bzChatClose" style="border:none;background:none;font-size:18px;cursor:pointer;">×</button>
        </div>

        <div class="bz-chat-body">
            <!-- Left column: unified list -->
            <div class="bz-chat-list" id="bzListColumn">
                <div class="chat-search">
                    <input type="text" id="bzChatSearch" placeholder="Search messages..." />
                </div>
                <div id="bzChatList"></div>
            </div>

            <!-- Right column: thread -->
            <div class="bz-chat-thread">
                <div id="bzChatTitle" class="bz-chat-title">Select a conversation</div>
                <div id="bzChatMessages" class="bz-chat-messages"></div>
                <form id="bzChatForm" class="bz-chat-input">
                    <input id="bzChatInput" type="text" placeholder="Type a message…" />
                    <button type="submit">Send</button>
                </form>
            </div>
        </div>
    </div>

    <!-- Twilio Conversations SDK -->
    <script>
    (async function(){
      // Dynamically load Twilio SDK
      function loadTwilioSDK() {
        return new Promise((resolve, reject) => {
          if (typeof Twilio !== "undefined" && Twilio?.Conversations?.Client) {
            console.log('[BZChat] Twilio SDK already loaded');
            resolve();
            return;
          }

          console.log('[BZChat] Loading Twilio SDK...');
          const script = document.createElement('script');
          script.src = 'https://sdk.twilio.com/js/conversations/releases/2.6.0/twilio-conversations.min.js';
          script.crossOrigin = 'anonymous';

          script.onload = () => {
            setTimeout(() => {
              if (typeof Twilio !== "undefined" && Twilio?.Conversations?.Client) {
                console.log('[BZChat] Twilio SDK loaded successfully');
                resolve();
              } else {
                reject(new Error("Twilio SDK loaded but not initialized"));
              }
            }, 200);
          };

          script.onerror = () => reject(new Error("Failed to load Twilio SDK script"));
          document.head.appendChild(script);

          setTimeout(() => {
            if (typeof Twilio === "undefined" || !Twilio?.Conversations?.Client) {
              reject(new Error("Twilio SDK load timeout"));
            }
          }, 30000);
        });
      }

      try {
        await loadTwilioSDK();
      } catch (error) {
        console.error('[BZChat] Failed to load Twilio SDK:', error);
        alert('Chat service unavailable. Please refresh the page.');
        return;
      }

      let twilioClient = null;
      let identity = null;
      let currentConv = null;
      let allConversations = [];
      let conversationMetadata = new Map();
      let myUserId = null;
      let hasUnread = false;

      // Tracks conversations we've already attached a global message listener to
      let subscribedConversationSids = new Set();

      // One listener per "open" thread so we can detach when switching
      let threadMessageListener = null;

      function updateGlobalUnreadIndicator() {
        const fab = document.getElementById('bzChatFab');
        const dot = document.getElementById('bzChatUnreadDot');
        if (!fab || !dot) return;
        
        if (hasUnread) {
          fab.classList.add('has-unread');
          dot.style.display = 'block';
        } else {
          fab.classList.remove('has-unread');
          dot.style.display = 'none';
        }
      }

      // Prevent form submission from redirecting
      const chatForm = document.getElementById('bzChatForm');
      const chatInput = document.getElementById('bzChatInput');

      if (chatForm) {
        chatForm.addEventListener('submit', async function(e) {
          e.preventDefault();
          e.stopPropagation();

          const msg = chatInput.value.trim();
          if (!msg || !currentConv) {
            console.log('[BZChat] Cannot send: no message or no conversation');
            return;
          }

          try {
            await currentConv.sendMessage(msg);
            chatInput.value = '';
            console.log('[BZChat] Message sent:', msg);

            // Refresh sidebar so last message preview / ordering stays updated
            loadUnifiedList();
          } catch (err) {
            console.error('[BZChat] Error sending message:', err);
            alert('Failed to send message. Please try again.');
          }
        });
      }

      // Initialize Twilio client
      try {
        const tokenResp = await fetch('/communication/messaging/token/');
        const tokenData = await tokenResp.json();

        if (!tokenData.token) {
          throw new Error('No token received');
        }

        identity = tokenData.identity;
        myUserId = extractUserIdFromIdentity(identity);
        twilioClient = new Twilio.Conversations.Client(tokenData.token);
        console.log('[BZChat] Twilio client initialized for:', identity, 'User ID:', myUserId);

        await initializeChatUI();
      } catch (err) {
        console.error('[BZChat] Failed to initialize chat:', err);
        alert('Failed to initialize chat. Please refresh the page.');
      }

      // Chat UI initialization
      async function initializeChatUI() {
        const fab = document.getElementById('bzChatFab');
        const panel = document.getElementById('bzChatPanel');
        const closeBtn = document.getElementById('bzChatClose');
        const searchInput = document.getElementById('bzChatSearch');

        fab.addEventListener('click', () => {
          panel.style.display = 'flex';
          loadUnifiedList();
        });

        closeBtn.addEventListener('click', () => {
          panel.style.display = 'none';
        });

        if (searchInput) {
          searchInput.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            filterConversations(query);
          });
        }

        await loadUnifiedList();
      }

      // Load unified conversations + connections
      async function loadUnifiedList() {
        const listContainer = document.getElementById('bzChatList');
        if (!listContainer) return;

        listContainer.innerHTML =
          '<div class="empty-state"><i class="fas fa-spinner fa-spin"></i><p>Loading...</p></div>';

        try {
          // Fetch both conversations and connections
          const [convsResp, connsResp] = await Promise.all([
            fetch('/communication/messaging/list/'),
            fetch('/communication/api/connections')
          ]);

          const convsData = await convsResp.json();
          const connections = await connsResp.json();

          // Get Twilio conversations for this user (ONLY shows conversations user is in)
          const convsPage = await twilioClient.getSubscribedConversations();
          allConversations = convsPage.items || [];
          console.log('[BZChat] Loaded', allConversations.length, 'Twilio conversations');

          conversationMetadata.clear();

          for (const conv of allConversations) {
            console.log('[BZChat] ========================================');
            console.log('[BZChat] Processing conversation:', conv.sid);
            console.log('[BZChat] Unique name:', conv.uniqueName);
            console.log('[BZChat] Raw attributes:', conv.attributes);

            const participants = await conv.getParticipants();
            console.log('[BZChat] Participants:', participants.map(p => p.identity));

            const otherParticipant = participants.find(p => p.identity !== identity);
            console.log('[BZChat] My identity:', identity);
            console.log('[BZChat] Other participant:', otherParticipant?.identity);

            // Figure out display name
            let displayName = 'Unknown';
            try {
              if (conv.attributes) {
                let attributes;
                if (typeof conv.attributes === 'string') {
                  console.log('[BZChat] Attributes is string, parsing...');
                  attributes = JSON.parse(conv.attributes);
                } else {
                  console.log('[BZChat] Attributes already parsed');
                  attributes = conv.attributes;
                }

                console.log('[BZChat] Parsed attributes:', attributes);
                console.log('[BZChat] Attribute keys:', Object.keys(attributes));

                const otherUserId = extractUserIdFromIdentity(otherParticipant?.identity);
                console.log('[BZChat] Other user ID:', otherUserId);

                const lookupKey = otherUserId ? `user_${otherUserId}` : null;

                if (lookupKey && attributes[lookupKey]) {
                  displayName = attributes[lookupKey];
                  console.log('[BZChat] ✓ Found display name:', displayName);
                } else {
                  console.log('[BZChat] ✗ Could not find friendly name in attributes');
                  if (otherParticipant?.identity) {
                    displayName = otherParticipant.identity.replace('user_', 'User ');
                    console.log('[BZChat] Using fallback name:', displayName);
                  }
                }
              } else {
                console.log('[BZChat] ✗ No attributes for conversation', conv.sid);
                if (otherParticipant?.identity) {
                  displayName = otherParticipant.identity.replace('user_', 'User ');
                }
              }
            } catch (err) {
              console.error('[BZChat] ✗ Error parsing attributes:', err);
              if (otherParticipant?.identity) {
                displayName = otherParticipant.identity.replace('user_', 'User ');
              }
            }

            console.log('[BZChat] Final display name:', displayName);

            let lastMessage = null;
            let lastTimestamp = null;

            try {
              const messages = await conv.getMessages(1);
              if (messages.items && messages.items.length > 0) {
                const msg = messages.items[0];
                lastMessage = msg.body;
                lastTimestamp = msg.dateCreated;
              }
            } catch (err) {
              console.log('[BZChat] No messages in conversation:', conv.sid);
            }

            // Unread count (per conv)
            let unreadCount = 0;
            try {
              if (typeof conv.getUnreadMessagesCount === 'function') {
                const unread = await conv.getUnreadMessagesCount();
                if (typeof unread === 'number' && unread > 0) {
                  unreadCount = unread;
                }
              }
            } catch (err) {
              console.log('[BZChat] Could not get unread count for', conv.sid, err);
            }

            conversationMetadata.set(conv.sid, {
              sid: conv.sid,
              friendlyName: displayName,
              otherIdentity: otherParticipant?.identity,
              lastMessage: lastMessage,
              lastTimestamp: lastTimestamp,
              unreadCount: unreadCount,
              conversation: conv
            });

            // Global listener for *incoming* messages in this conversation
            // Only attach once per SID to avoid spam reloads
            if (!subscribedConversationSids.has(conv.sid)) {
              subscribedConversationSids.add(conv.sid);
              conv.on('messageAdded', (msg) => {
                // CRITICAL: Only process messages from OTHER users (not from me)
                if (msg.author !== identity) {
                  console.log('[BZChat] Incoming message from', msg.author, 'in', conv.sid);
                  
                  // Update unread count for this conversation
                  const meta = conversationMetadata.get(conv.sid);
                  if (meta) {
                    meta.unreadCount = (meta.unreadCount || 0) + 1;
                    meta.lastMessage = msg.body;
                    meta.lastTimestamp = msg.dateCreated;
                  }
                  
                  // Set global unread flag
                  hasUnread = true;
                  updateGlobalUnreadIndicator();
                  
                  // Refresh sidebar to show new message preview
                  loadUnifiedList();
                } else {
                  console.log('[BZChat] Ignoring my own message in', conv.sid);
                }
              });
            }

            console.log('[BZChat] ========================================');
          }

          // Compute global unread
          hasUnread = false;
          conversationMetadata.forEach(meta => {
            if (meta.unreadCount && meta.unreadCount > 0) {
              hasUnread = true;
            }
          });
          updateGlobalUnreadIndicator();

          // Build unified items array
          const items = [];

          // Conversations
          conversationMetadata.forEach((meta) => {
            items.push({
              type: 'conversation',
              sid: meta.sid,
              name: meta.friendlyName,
              lastMessage: meta.lastMessage,
              timestamp: meta.lastTimestamp,
              unreadCount: meta.unreadCount || 0,
              userId: extractUserIdFromIdentity(meta.otherIdentity)
            });
          });

          // Add connections that don't yet have a conversation
          for (const conn of connections) {
            const hasConversation = Array.from(conversationMetadata.values())
              .some(meta => meta.otherIdentity === `user_${conn.id}`);
            if (!hasConversation) {
              items.push({
                type: 'connection',
                userId: conn.id,
                name: conn.username,
                lastMessage: 'Start a conversation',
                timestamp: null,
                unreadCount: 0
              });
            }
          }

          // Sort by most recent
          items.sort((a, b) => {
            if (!a.timestamp) return 1;
            if (!b.timestamp) return -1;
            return b.timestamp - a.timestamp;
          });

          if (items.length === 0) {
            listContainer.innerHTML =
              '<div class="empty-state"><i class="fas fa-comments"></i><p>No conversations yet</p></div>';
            return;
          }

          // Render sidebar list with unread badges
          listContainer.innerHTML = items.map(item => {
            const unreadClass = item.unreadCount > 0 ? 'has-unread' : '';
            const unreadBadge = item.unreadCount > 0 
              ? `<span class="unread-badge">${item.unreadCount > 99 ? '99+' : item.unreadCount}</span>` 
              : '';
            
            return `
              <div class="bz-chat-list-item ${unreadClass}"
                   data-type="${item.type}"
                   data-sid="${item.sid || ''}"
                   data-user-id="${item.userId || ''}"
                   data-name="${escapeHtml(item.name)}">
                <div class="chat-user-name">
                  ${escapeHtml(item.name)}
                  ${unreadBadge}
                </div>
                <div class="chat-last-message">${escapeHtml(item.lastMessage || 'No messages yet')}</div>
                ${item.timestamp ? `<div class="chat-timestamp">${formatTimestamp(item.timestamp)}</div>` : ''}
              </div>
            `;
          }).join('');

          // Click handlers
          document.querySelectorAll('.bz-chat-list-item').forEach(el => {
            el.addEventListener('click', async () => {
              document.querySelectorAll('.bz-chat-list-item').forEach(item => {
                item.classList.remove('active');
              });
              el.classList.add('active');

              const type = el.dataset.type;
              if (type === 'conversation') {
                await openConversation(el.dataset.sid);
              } else {
                await openWithUser(el.dataset.userId, el.dataset.name);
              }
            });
          });

        } catch (err) {
          console.error('[BZChat] Failed to load unified list:', err);
          listContainer.innerHTML =
            '<div class="empty-state" style="color:red;"><i class="fas fa-exclamation-triangle"></i><p>Failed to load conversations</p></div>';
        }
      }

      // Filter sidebar by query
      function filterConversations(query) {
        query = (query || '').toLowerCase();
        document.querySelectorAll('.bz-chat-list-item').forEach(el => {
          const name = (el.dataset.name || '').toLowerCase();
          const lastMsgEl = el.querySelector('.chat-last-message');
          const lastMsg = (lastMsgEl ? lastMsgEl.textContent : '').toLowerCase();

          if (name.includes(query) || lastMsg.includes(query)) {
            el.style.display = 'block';
          } else {
            el.style.display = 'none';
          }
        });
      }

      // Open conversation by SID
      async function openConversation(sid) {
        console.log('[BZChat] Opening conversation:', sid);

        try {
          const meta = conversationMetadata.get(sid);

          // Detach previous thread listener
          if (currentConv && threadMessageListener) {
            currentConv.removeListener('messageAdded', threadMessageListener);
          }

          if (meta && meta.conversation) {
            currentConv = meta.conversation;
          } else {
            currentConv = await twilioClient.getConversationBySid(sid);
          }

          console.log('[BZChat] Conversation loaded:', currentConv.sid);

          let displayTitle = 'Conversation';
          if (meta && meta.friendlyName) {
            displayTitle = meta.friendlyName;
          } else {
            displayTitle = currentConv.friendlyName || currentConv.uniqueName || 'Conversation';
          }
          document.getElementById('bzChatTitle').textContent = displayTitle;

          const msgContainer = document.getElementById('bzChatMessages');

          // Load messages
          let messageItems = [];
          try {
            const messages = await currentConv.getMessages();
            messageItems = messages.items || [];
            console.log('[BZChat] Loaded', messageItems.length, 'messages');
          } catch (msgErr) {
            console.log('[BZChat] No messages yet:', msgErr.message);
          }

          if (messageItems.length === 0) {
            msgContainer.innerHTML =
              '<div class="empty-state"><i class="fas fa-comments"></i><p>No messages yet. Start the conversation!</p></div>';
          } else {
            msgContainer.innerHTML = messageItems
              .map(m => {
                const isOwn = m.author === identity;
                return `
                  <div class="bz-chat-bubble ${isOwn ? 'bz-me' : 'bz-them'}">
                    ${escapeHtml(m.body)}
                  </div>
                `;
              }).join('');
          }

          msgContainer.scrollTop = msgContainer.scrollHeight;

          // Thread-specific listener: update the open thread view ONLY
          threadMessageListener = (msg) => {
            console.log('[BZChat] New message received from', msg.author);
            const isOwn = msg.author === identity;

            const emptyState = msgContainer.querySelector('.empty-state');
            if (emptyState) {
              emptyState.remove();
            }

            const div = document.createElement('div');
            div.className = `bz-chat-bubble ${isOwn ? 'bz-me' : 'bz-them'}`;
            div.innerHTML = escapeHtml(msg.body);
            msgContainer.appendChild(div);
            msgContainer.scrollTop = msgContainer.scrollHeight;
            
            // CRITICAL: If it's MY message, mark it as read immediately
            // (prevents seeing notification for my own sent messages)
            if (isOwn && currentConv) {
              setTimeout(async () => {
                try {
                  if (typeof currentConv.setAllMessagesRead === 'function') {
                    await currentConv.setAllMessagesRead();
                    console.log('[BZChat] Marked my own message as read');
                  }
                } catch (err) {
                  console.warn('[BZChat] Failed to mark own message as read:', err);
                }
              }, 100);
            }
          };

          currentConv.on('messageAdded', threadMessageListener);

          // Mark messages as read
          try {
            if (typeof currentConv.setAllMessagesRead === 'function') {
              const remaining = await currentConv.setAllMessagesRead();
              console.log('[BZChat] Marked all messages read, remaining unread:', remaining);

              // Update local metadata
              const updatedMeta = conversationMetadata.get(currentConv.sid);
              if (updatedMeta) {
                updatedMeta.unreadCount = remaining || 0;
              }

              // Recalculate global unread indicator
              hasUnread = false;
              conversationMetadata.forEach(m => {
                if (m.unreadCount && m.unreadCount > 0) {
                  hasUnread = true;
                }
              });
              updateGlobalUnreadIndicator();

              // Update the sidebar item visually
              const sidebarItem = document.querySelector(`.bz-chat-list-item[data-sid="${currentConv.sid}"]`);
              if (sidebarItem) {
                sidebarItem.classList.remove('has-unread');
                const badge = sidebarItem.querySelector('.unread-badge');
                if (badge) {
                  badge.remove();
                }
              }
            }
          } catch (err) {
            console.warn('[BZChat] Failed to mark messages as read:', err);
          }

          console.log('[BZChat] Conversation ready');
        } catch (err) {
          console.error('[BZChat] Failed to open conversation:', err);
          const msgContainer = document.getElementById('bzChatMessages');
          msgContainer.innerHTML = `
            <div class="empty-state" style="color:#d32f2f;">
              <i class="fas fa-exclamation-triangle"></i>
              <p><strong>Error loading conversation</strong></p>
              <p style="font-size:12px;margin-top:8px;">${escapeHtml(err.message)}</p>
            </div>
          `;
        }
      }

      // Start / open conversation with a specific user
      async function openWithUser(userId, name) {
        try {
          console.log(`[BZChat] Starting conversation with user ${userId} (${name})`);

          const resp = await fetch(`/communication/messaging/start/${userId}/`);

          if (!resp.ok) {
            const data = await resp.json();
            throw new Error(data.error || `Server returned ${resp.status}`);
          }

          const data = await resp.json();
          console.log('[BZChat] Start conversation response:', data);

          if (!data.ok || !data.sid) {
            throw new Error(data.error || 'Failed to start conversation');
          }

          console.log('[BZChat] Opening conversation SID:', data.sid);
          await openConversation(data.sid);
          await loadUnifiedList();
        } catch (err) {
          console.error('[BZChat] Failed to open conversation with user:', err);
          alert('Failed to start conversation: ' + err.message);
        }
      }

      // Expose for external click handler
      window.BZChat = { openWithUser };

      // If there was a pending chat request from a profile button click, handle it
      if (window.__BZ_PENDING_CHAT__) {
        const { userId, name } = window.__BZ_PENDING_CHAT__;
        await openWithUser(userId, name);
        delete window.__BZ_PENDING_CHAT__;
      }

      // Helper functions
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function extractUserIdFromIdentity(identity) {
        if (!identity) return null;
        const match = identity.match(/user_(\d+)/);
        const userId = match ? match[1] : null;
        console.log('[BZChat] extractUserIdFromIdentity:', identity, '→', userId);
        return userId;
      }

      function formatTimestamp(date) {
        if (!date) return '';
        const now = new Date();
        const diff = now - date;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(diff / 3600000);
        const days = Math.floor(diff / 86400000);

        if (minutes < 1) return 'Just now';
        if (minutes < 60) return `${minutes}m ago`;
        if (hours < 24) return `${hours}h ago`;
        if (days < 7) return `${days}d ago`;
        return date.toLocaleDateString();
      }

    })();
    </script>
    {% endif %}

    <!-- Messages auto-hide -->
    <script>
      setTimeout(() => {
        document.querySelectorAll('.messages .message').forEach(el => {
          el.style.transition = 'opacity .3s ease, transform .3s ease';
          el.style.opacity = '0';
          el.style.transform = 'translateY(-6px)';
          setTimeout(() => el.remove(), 300);
        });
      }, 3000);
    </script>

    <script>
    /* Minimal, bomb-proof interceptor for .js-open-chat */
    (function(){
      function handle(ev){
        const a = ev.target.closest('a.js-open-chat,button.js-open-chat');
        if (!a) return;
        ev.preventDefault();
        ev.stopPropagation();
        const userId = a.getAttribute('data-user-id');
        const name = a.getAttribute('data-name') || '';
        console.log('[BZChat] Intercepted click for user:', userId, name);

        const panel = document.getElementById('bzChatPanel');
        if (panel) panel.style.display = 'flex';

        if (window.BZChat && typeof window.BZChat.openWithUser === 'function') {
          window.BZChat.openWithUser(String(userId), name);
        } else {
          window.__BZ_PENDING_CHAT__ = { userId: String(userId), name };
        }
      }
      document.addEventListener('click', handle, true);
    })();
    </script>

</body>
</html>